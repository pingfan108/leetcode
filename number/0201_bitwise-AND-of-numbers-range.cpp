/*
# 201. 数字范围按位与
https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/

给定范围 [m, n]，返回此范围内所有数字的按位与（包含 m, n 两端点）。
其中, 0 <= m <= n <= 2147483647

    示例 1: 
输入: [5,7]
输出: 4
    示例 2:
输入: [0,1]
输出: 0
 */

// 解法1: 暴力法
// 思路:
// * 基于题目的定义说明, 做(n-m)次与运算后直接得到结果
// 实现略

// 解法2: 位移法
// 思路:
// * 求范围按位与, 等价于求得范围上下限数字的二进制公共前缀后在末尾补零(对公共
//   前缀后面的位来说, 在依次运算过程中一定会遇到0/1跳变, 根据与运算的定义, 这
//   些位的结果为0);
// * 同时对范围的下限m和上限n做右移运算, 直到两数相等, 记为m'; 同时记录此过程中
//   右移的位数, 将m'再左移相应位数(即末尾补零), 即为所求结果.
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        // 通过位移法找二者的二进制公共前缀
        int shift = 0;  // 记录找前缀过程中右移的次数
        while (m < n) {
            m >>= 1;
            n >>= 1;
            shift++;
        }
        // 找到公共前缀, 左移相应位数, 即为所求结果
        return m << shift;
    }
};

// 解法3: Brian Kernigham算法
// 思路:
// * 求范围按位与, 等价于求得范围上下限数字的二进制公共前缀后在末尾补零(对公共
//   前缀后面的位来说, 在依次运算过程中一定会遇到0/1跳变, 根据与运算的定义, 这
//   些位的结果为0);
// * 取范围上限n, 通过Brian Kernigham算法逐步清除其右边的1, 直到n'不大于下限m,
//   此时二者公共前缀之后的1都已被清除, n'即为所求结果.
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        // 通过Brian Kernigham算法找二者的二进制公共前缀
        while (m < n) {
            n = n & (n-1);
        }
        // 将二者二进制公共前缀之后的1都清除的n, 即为所求结果
        return n;
    }
};
