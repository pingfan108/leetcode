/*
# 695. 岛屿的最大面积
https://leetcode-cn.com/problems/max-area-of-island/

给定一个包含了一些 0 和 1 的非空二维数组 grid 。一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，
这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)
注意: 给定的矩阵grid 的长度和宽度都不超过 50。

    示例 1:
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。

    示例 2:
[[0,0,0,0,0,0,0,0]]
对于上面这个给定的矩阵, 返回 0。
 */

// 解法1: 深度优先搜索
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int res = 0;
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                res = std::max(res, dfs(grid, i, j));
            }
        }
        return res;
    }

    // 基于深度优先策略搜索当前岛屿(i,j分别表示行号和列号)
    int dfs(vector<vector<int>>& grid, int i, int j) {
        if (i < 0 || i >= grid.size()            // 超出上下边界
                || j < 0 || j >= grid[0].size()  // 超出左右边界
                || grid[i][j] != 1) {            // "水域"或已访问的"陆地"
            return 0;
        }

        // 找到一块新"陆地", 标记已访问
        grid[i][j] = 2;
        // 继续遍历四周, 找到所有相邻"陆地", 累加其面积
        return 1 + dfs(grid, i-1, j)
                + dfs(grid, i+1, j)
                + dfs(grid, i, j-1)
                + dfs(grid, i, j+1);
    }
};
