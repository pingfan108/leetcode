/*
96. 不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

	示例:
输入: 3
输出: 5
解释: 给定 n = 3, 一共有如下 5 种不同结构的二叉搜索树:
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
*/

// 解法1: 基于动态规划(BST的种类数仅和有序序列的长度相关, 跟序列具体取值无关!)
// 备注: 本质上这是一个卡特兰数公式求解
class Solution {
public:
    int numTrees(int n) {
        if (n <= 1) return 1;

        //// Step1: 创建并初始化状态转移数组, dp[i]表示由长度为i的有序序列组成的BST种类数
        int dp[n+1];
        memset(dp, 0, sizeof(int)*(n+1));
        dp[0] = 1;  // 空二叉树
        dp[1] = 1;  // 只有根节点的二叉树
        //// Step2: 依次填充状态转移数组
        for (int i = 2; i <= n; i++) {       // i表示有序序列总长度
            for (int j = 0; j < i; j++) {    // j表示组成左子树的有序子序列长度
                // 固定BST根节点为j+1, 右子树节点数为i-1-j
                dp[i] += dp[j] * dp[i-1-j];  // 左子树种类数 * 右子树种类数
            }
        }
        //// Step3: dp[n]即为题解
        return dp[n];
    }
};

// 解法2: 基于折半优化的动态规划
class Solution {
public:
    int numTrees(int n) {
        if (n <= 1) return 1;

        //// Step1: 创建并初始化状态转移数组, dp[i]表示由长度为i的有序序列组成的BST种类数
        int dp[n+1];
        memset(dp, 0, sizeof(int)*(n+1));
        dp[0] = 1;  // 空二叉树
        dp[1] = 1;  // 只有根节点的二叉树
        //// Step2: 依次填充状态转移数组
        // i表示有序序列长度
        for (int i = 2; i <= n; i++) {
            // j表示组成左子树的有序子序列长度
            // 基于二叉树左右子树的可交换性, 后一半的结果与前一半镜像对称, 只需算一半乘2即可. 
            int mid = i >> 1;
            for (int j = 0; j < mid; j++) {
                // 固定BST根节点为j+1, 右子树节点数为i-1-j
                dp[i] += (dp[j] * dp[i-1-j]) << 1;  // 左子树种类数 * 右子树种类数 * 2
            }
            // 当i为奇数时, 需补上左右子序列长度相等的情况
            if (i&1) {
                dp[i] += dp[mid] * dp[mid];
            }
        }
        // Step3: dp[n]即为题解
        return dp[n];
    }
};
